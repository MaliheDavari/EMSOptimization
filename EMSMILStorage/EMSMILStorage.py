from gurobipy import *
import matplotlib.pyplot as plt
import numpy as np
####################################################################################
#Data

# availabe power: PV, wind
T=list(range(1,25)) #period 24 hours
G=['gen1','gen2']   #diesel generators
I=['pv','wt']       #RESs (photovoltaic panels, wind turbine)
TI=1                #Time interval
#Storage data
CAP=40              #Nominal capacity of the battery (kWh)
eff_disch=0.9       #Discharging efficiency
eff_ch=0.9          #Charging efficiency
P_s_disch_max=10    #Max power discharging
P_s_ch_max=10       #Max power charging
SoC0=0.5            #Initial state of battery
SoCmin=0.2          #Min state of battery
SoCmax=0.9          #Max state of battery
#price utility in each time interval in $/kWh
price_utility = {
    1: 2.264, 2: 1.9, 3: 1.398, 4: 1.2, 5: 1.153, 6: 1.994, 7: 2.301, 8: 3.837,
    9: 14.986, 10: 40, 11: 40, 12: 40, 13: 14.986, 14: 40, 15: 20.1, 16: 19.499,
    17: 6, 18: 4.13, 19: 3.516, 20: 4.395, 21: 11.712, 22: 5.4, 23: 3, 24: 2.557
}

# power demandd in kW in each time interval
P_load = {
    1: 75, 2: 60, 3: 55, 4: 54, 5: 50, 6: 54, 7: 80, 8: 100, 9: 130, 10: 150,
    11: 170, 12: 180, 13: 180, 14: 180, 15: 180, 16: 178, 17: 170, 18: 180,
    19: 200, 20: 190, 21: 180, 22: 160, 23: 140, 24: 100
}

# generators data (gen1 ,gen2)
price_p_gen={'gen1':4.37,'gen2':2.84}       #power generation price in $/kWh
price_c_gen={'gen1':85.6,'gen2':255.18}     #contsnt price in $/h
P_gen_max={'gen1': 40, 'gen2': 30}          # maximum power generation in kW
RU_gen={'gen1':6,'gen2':5}                  # Round UP power in generators
RD_gen={'gen1':6,'gen2':5}                  #Round down power in generators
# maximum available power of RESs in kW
P_grid_max=200  #Max power injected to the grid in kW

P_res_max = {
    1: {'pv': 0, 'wt': 9.3}, 2: {'pv': 0, 'wt': 13.8}, 3: {'pv': 0, 'wt': 16.8},
    4: {'pv': 0, 'wt': 21.3}, 5: {'pv': 0, 'wt': 6.3}, 6: {'pv': 0, 'wt': 12.6},
    7: {'pv': 3.6, 'wt': 18.9}, 8: {'pv': 6, 'wt': 14.7}, 9: {'pv': 8.7, 'wt': 19.2},
    10: {'pv': 7.2, 'wt': 12.6}, 11: {'pv': 6.75, 'wt': 15.9}, 12: {'pv': 3.3, 'wt': 10.2},
    13: {'pv': 5.25, 'wt': 9.3}, 14: {'pv': 16.8, 'wt': 13.8}, 15: {'pv': 12, 'wt': 16.8},
    16: {'pv': 7.2, 'wt': 21.3}, 17: {'pv': 3.6, 'wt': 29.4}, 18: {'pv': 0, 'wt': 26.4},
    19: {'pv': 0, 'wt': 29.4}, 20: {'pv': 0, 'wt': 30.6}, 21: {'pv': 0, 'wt': 19.2},
    22: {'pv': 0, 'wt': 12.6}, 23: {'pv': 0, 'wt': 15.9}, 24: {'pv': 0, 'wt': 10.2}
}

####################################################################################
# create model
m=Model('EMS_MG')
####################################################################################
# decision variables: P_grid, diesel generators, and RESs
P_grid=m.addVars(T,vtype=GRB.CONTINUOUS,name="P_grid")
P_gen=m.addVars(T,G,vtype=GRB.CONTINUOUS,name="P_gen")      #power generated by diesel generators
P_res=m.addVars(T,I,vtype=GRB.CONTINUOUS,name="P_res")      #RESs
cost=m.addVar(vtype=GRB.CONTINUOUS,name='cost')

# Storage vars
P_s_ch=m.addVars(T,vtype=GRB.CONTINUOUS, name='P_s_ch')
P_s_disch=m.addVars(T,vtype=GRB.CONTINUOUS, name='P_s_disch')
SoC=m.addVars(T,vtype=GRB.CONTINUOUS, name='SoC')

# add boolean for battery
X_s = m.addVars(T,vtype=GRB.BINARY, name="X_s")                # if 1 is charging if 0 disch
####################################################################################
#Constraints
P_grid_const=m.addConstrs((P_grid[t]<=P_grid_max for t in T),name="P_grid_up")
P_res_const=m.addConstrs((P_res[t,i]<=P_res_max[t][i] for t in T for i in I), name="P_res_up")
P_gen_const=m.addConstrs((P_gen[t,g]<=P_gen_max[g] for t in T for g in G), name="P_gen_up")
RU_const=m.addConstrs((P_gen[t+1,g]-P_gen[t,g]<=RU_gen[g] for t in T[:-1] for g in G), name='RU_const')
RD_const=m.addConstrs((P_gen[t,g]-P_gen[t+1,g]<=RD_gen[g] for t in T[:-1] for g in G), name='RD_const')
cost_const=m.addConstr(cost == quicksum(P_grid[t] * TI * price_utility[t] for t in T) + quicksum(P_gen[t, g] * TI * price_p_gen[g] + price_c_gen[g] * TI for t in T for g in G),
                         name='cost_function')
#Battery constraints
SoC_const0=m.addConstrs((SoC[t]==SoC0+eff_ch*P_s_ch[t]*TI/CAP-P_s_disch[t]*TI/(eff_disch*CAP) for t in [T[0]]), name='SOC_const0')
SoC_const=m.addConstrs((SoC[t]==SoC[t-1]+eff_ch*P_s_ch[t]*TI/CAP-P_s_disch[t]*TI/(eff_ch*CAP) for t in T[1:]), name='SoC_const')
SoC_final=m.addConstr(SoC[T[-1]]==SoC0 ,name='SoC_final')
P_balance_const=m.addConstrs((P_load[t]==P_grid[t]+ quicksum(P_gen[t,g] for g in G)+P_s_disch[t]-P_s_ch[t]
                               +quicksum(P_res[t,i] for i in I) for t in T), name="P_balance")

SOC_max_const=m.addConstrs((SoC[t]<=SoCmax for t in T), name='SoC_max_const')
SoC_min_const=m.addConstrs((SoC[t]>=SoCmin for t in T), name='SoC_min_const')
P_ch_const=m.addConstrs((P_s_ch[t]<=P_s_ch_max*X_s[t] for t in T), name='P_ch_const')
P_disch_const=m.addConstrs((P_s_disch[t]<=P_s_disch_max*(1-X_s[t]) for t in T), name='P_disch_const')
####################################################################################
# Objective
m.setObjective(cost,GRB.MINIMIZE)

#Solve
m.optimize()

#display the results
if m.Status==GRB.OPTIMAL:
    for v in m.getVars():
        print('%s %g' % (v.varName, v.x))
    print('Obj: %g' % m.objVal)



####################################################################################
#Two diagrams to display powers and the state of the charge of battery
fig, axs = plt.subplots(2, 1, figsize=(10, 12))

# First plot for Powers
axs[0].plot(T, [P_res[t, 'pv'].x for t in T], label="PV")
axs[0].plot(T, [P_res[t, 'wt'].x for t in T], label='Wind Turbine')
axs[0].plot(T, [P_grid[t].x for t in T], label='Power from Grid')
axs[0].plot(T, [P_gen[t, 'gen1'].x for t in T], label='Generator number 1')
axs[0].plot(T, [P_gen[t, 'gen2'].x for t in T], label='Generator number 2')
axs[0].plot(T, [P_load[t] for t in T], label='Load')
axs[0].set_xlabel('Time [h]')
axs[0].set_ylabel('Power[kW]')
axs[0].set_title('Powers')
axs[0].legend()
axs[0].grid(True)

# Second plot for State of Charge
soc_values = [SoC[t].x for t in T]
axs[1].plot(T, soc_values, label='State of Charge (SoC)')
axs[1].set_xlabel('Time [h]')
axs[1].set_ylabel('State of Charge')
axs[1].set_title('Battery State of Charge Of Battery')
axs[1].grid(True)
axs[1].legend()

plt.tight_layout()

 # Show plots
plt.show()